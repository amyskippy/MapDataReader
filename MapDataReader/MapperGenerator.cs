using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;

namespace MapDataReader
{
	/// <summary>
	/// An attribute used to mark a class for which a data reader mapper will be generated.
	/// </summary>
	/// <remarks>
	/// The auto-generated mappers will help in mapping data from a data reader to the class properties.
	/// </remarks>
	[AttributeUsage(AttributeTargets.Class)]
	public class GenerateDataReaderMapperAttribute : Attribute
	{
		/// <summary>
		/// Gets or sets the access modifier for the generated methods.
		/// </summary>
		/// <value>
		/// A string representing the access modifier (e.g., "public", "internal") for the generated methods.
		/// </value>
		public string AccessModifier { get; set; }

		/// <inheritdoc />
		public GenerateDataReaderMapperAttribute()
		{
			AccessModifier = "public";
		}

		/// <param name="access">
		/// Change the access modifier of the generated methods.
		/// See <see cref="AccessModifier"/> for more information.
		/// </param>
		/// <inheritdoc />
		public GenerateDataReaderMapperAttribute(string access = "public")
		{
			AccessModifier = access;
		}
	}

	/// <summary>
	/// A source generator responsible for creating mapping extensions that allow for setting properties of a class
	/// based on the property name using data from a data reader.
	/// </summary>
	/// <remarks>
	/// This generator scans for classes marked with specific attributes and generates an extension method
	/// that facilitates setting properties by their names.
	/// </remarks>
	[Generator]
	public class MapperGenerator : ISourceGenerator
	{
		private const string Newline = @"
";

		/// <summary>
		/// Executes the source generation logic, which scans for types needing generation,
		/// processes their properties, and generates the corresponding source code for mapping extensions.
		/// </summary>
		public void Execute(GeneratorExecutionContext context)
		{
			if (context.SyntaxContextReceiver is not TargetTypeTracker targetTypeTracker)
			{
				return;
			}

			foreach (var typeNode in targetTypeTracker.TypesNeedingGening)
			{
				var typeNodeSymbol = context.Compilation
					.GetSemanticModel(typeNode.SyntaxTree)
					.GetDeclaredSymbol(typeNode);

				if (typeNodeSymbol is null)
				{
					continue;
				}

				var allProperties = typeNodeSymbol.GetAllSettableProperties();

				var accessModifier = GetAccessModifer(typeNode);

				var src = $$"""
					// <auto-generated/>
					#pragma warning disable 8019 //disable 'unnecessary using directive' warning
					using System;
					using System.Data;
					using System.Linq;
					using System.Collections.Generic; //to support List<T> etc

					namespace MapDataReader;
					
					/// <summary>
					/// MapDataReader extension methods
					/// </summary>
					/// <seealso cref="{{typeNodeSymbol.FullName()}}">{{typeNode.Identifier}}</seealso>
					{{accessModifier}} static class {{typeNode.Identifier}}Extensions
					{
						/// <summary>
						/// Fast compile-time method for setting a property value by name
						/// </summary>
						/// <seealso cref="{{typeNodeSymbol.FullName()}}">{{typeNode.Identifier}}</seealso>
						{{accessModifier}} static void SetPropertyByName(this {{typeNodeSymbol.FullName()}} target, string name, object value)
						{
							SetPropertyByUpperName(target, name.ToUpperInvariant(), value);
						}

						private static void SetPropertyByUpperName(this {{typeNodeSymbol.FullName()}} target, string name, object value)
						{   {{
								Newline + allProperties.Select(p =>
								{
									var pTypeName = p.Type.FullName();

									if (p.Type.IsReferenceType) //ref types - just cast to property type
									{
										return $"\t\tif (name == \"{p.Name.ToUpperInvariant()}\") {{ target.{p.Name} = value as {pTypeName}; return; }}";
									}

									if (p.Type.TryGetNullableValueUnderlyingType(out var underlyingType) && !underlyingType.IsEnum()) //nullable type (unless nullable Enum)
									{
										var nonNullableTypeName = pTypeName.TrimEnd('?');

										// do not use "as" operator because "as" is slow for nullable types. Use "is" and a null-check
										return $"\t\tif (name == \"{p.Name.ToUpperInvariant()}\") {{ if(value==null) target.{p.Name}=null; else if(value is {nonNullableTypeName}) target.{p.Name}=({nonNullableTypeName})value; return; }}";
									}

									if (p.Type.TryGetEnum(out var enumTypeSymbol) || underlyingType.TryGetEnum(out enumTypeSymbol))
									{
										var eTypeName = enumTypeSymbol.FullName(); // e.g. int, byte, short
										
										// enum? pre-convert to underlying type then to int, you can't cast a boxed int to enum directly.
										// Also to support assigning "smallint" database col to int32 (for example), which does not work at first (you can't cast a boxed "byte" to "int")
										// pre-convert enums to eTypeName (int, byte, short) first (after unboxing, see below)
										return $"\t\tif (value != null && name == \"{p.Name.ToUpperInvariant()}\") {{ target.{p.Name} = ({pTypeName})(value.GetType() == typeof({eTypeName}) ? ({eTypeName})value : ({eTypeName})Convert.ChangeType(value, typeof({eTypeName}))); return; }}"; 
									}

									// primitive types. use Convert.ChangeType before casting.
									// To support assigning "smallint" database col to int32 (for example),
									// which does not work at first (you can't cast a boxed "byte" to "int")
									return $"\t\tif (value != null && name == \"{p.Name.ToUpperInvariant()}\") {{ target.{p.Name} = value.GetType() == typeof({pTypeName}) ? ({pTypeName})value : ({pTypeName})Convert.ChangeType(value, typeof({pTypeName})); return; }}";
								}).StringConcat(Newline)
							}}
						}
						
					""";


				if (typeNodeSymbol.InstanceConstructors.Any(c => !c.Parameters.Any())) //has a constructor without parameters?
				{
					src += $$"""
						
						/// <summary>
						/// Map the data reader to <see cref="{{typeNodeSymbol.FullName()}}">{{typeNode.Identifier}}</see>
						/// </summary>
						/// <seealso cref="{{typeNodeSymbol.FullName()}}">{{typeNode.Identifier}}</seealso>
						[Obsolete("Use To<T> instead, this will be removed in future versions.")]
						{{accessModifier}} static List<{{typeNodeSymbol.FullName()}}> To{{typeNode.Identifier}}(this IDataReader dr)
						{
							return dr.To<{{typeNodeSymbol.FullName()}}>();
						}
						
						/// <summary>
						/// Map the data reader to <see cref="{{typeNodeSymbol.FullName()}}">{{typeNode.Identifier}}</see>
						/// </summary>
						/// <seealso cref="{{typeNodeSymbol.FullName()}}">{{typeNode.Identifier}}</seealso>
						{{accessModifier}} static List<{{typeNodeSymbol.FullName()}}> To<T>(this IDataReader dr) where T : {{typeNodeSymbol.FullName()}}
						{
							var list = new List<{{typeNodeSymbol.FullName()}}>();
							
							if (dr.Read())
							{
								string[] columnNames = new string[dr.FieldCount];
								
								for (int i = 0; i < columnNames.Length; i++)
								    columnNames[i] = dr.GetName(i).ToUpperInvariant();
								    
								do
								{
								    var result = new {{typeNodeSymbol.FullName()}}();
								    for (int i = 0; i < columnNames.Length; i++)
								    {
								        var value = dr[i];
								        if (value is DBNull) value = null;
								        SetPropertyByUpperName(result, columnNames[i], value);
								    }
									list.Add(result);
								} while (dr.Read());
							}
							dr.Close();
							return list;
						}
					
					""";
				}
				
				// end class
				src += $"{Newline}}}";

				// Add the source code to the compilation
				context.AddSource($"{typeNodeSymbol.Name}DataReaderMapper.g.cs", src);
			}
		}

		/// <summary>
		/// Initializes the generator. This method is called before any generation occurs and allows
		/// for setting up any necessary context or registering for specific notifications.
		/// </summary>
		public void Initialize(GeneratorInitializationContext context)
		{
			context.RegisterForSyntaxNotifications(() => new TargetTypeTracker());
		}

		private string GetAccessModifer(ClassDeclarationSyntax typeNode)
		{
			// Retrieve the attribute list
			var attributeList = typeNode.AttributeLists
				.SelectMany(al => al.Attributes)
				.FirstOrDefault(attr => attr.Name.ToString() == "GenerateDataReaderMapper");

			if (attributeList?.ArgumentList == null)
				return "public";

			var arguments = attributeList.ArgumentList.Arguments;

			if (arguments.Count == 0)
				return "public";

			if (arguments.Count == 1)
			{
				var argumentExpr = arguments[0].Expression as LiteralExpressionSyntax;
				return argumentExpr?.Token.ValueText ?? "public";
			}

			foreach (var argument in arguments)
			{
				// Check if the argument is a named argument
				if (argument is { NameEquals.Name.Identifier.Text: "AccessModifier" })
				{
					var argumentExpr = argument.Expression as LiteralExpressionSyntax;
					return argumentExpr?.Token.ValueText ?? "public";
				}
			}

			return "public";
		}
	}

	internal class TargetTypeTracker : ISyntaxContextReceiver
	{
		public IImmutableList<ClassDeclarationSyntax> TypesNeedingGening = ImmutableList.Create<ClassDeclarationSyntax>();

		public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
		{
			if (context.Node is not ClassDeclarationSyntax classDec) return;
			
			if (classDec.IsDecoratedWithAttribute("GenerateDataReaderMapper"))
				TypesNeedingGening = TypesNeedingGening.Add(classDec);
		}
	}

	internal static class Helpers
	{
		internal static bool IsDecoratedWithAttribute(this TypeDeclarationSyntax typeDec, string attributeName) =>
			typeDec.AttributeLists
				.SelectMany(x => x.Attributes)
				.Any(x => x.Name.ToString().Contains(attributeName));

		internal static string FullName(this ITypeSymbol typeSymbol) => typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

		internal static string StringConcat(this IEnumerable<string> source, string separator) => string.Join(separator, source);

		/// <summary>
		/// Returns all properties with public setters
		/// </summary>
		internal static IEnumerable<IPropertySymbol> GetAllSettableProperties(this ITypeSymbol typeSymbol)
		{
			var result = typeSymbol
				.GetMembers()
				.Where(s => s.Kind == SymbolKind.Property).Cast<IPropertySymbol>() //get all properties
				.Where(p => p.SetMethod?.DeclaredAccessibility == Accessibility.Public) //has a public setter?
				.ToList();

			//now get the base class
			var baseType = typeSymbol.BaseType;
			if (baseType != null)
				result.AddRange(baseType.GetAllSettableProperties()); //recursion

			return result;
		}
		
		/// <summary>
		/// Checks if the type is nullable
		/// </summary>
		internal static bool IsNullable(this ITypeSymbol typeSymbol)
		{
			if (typeSymbol.NullableAnnotation == NullableAnnotation.Annotated)
				return true;
			
			return typeSymbol is INamedTypeSymbol 
			{
				OriginalDefinition.SpecialType: SpecialType.System_Nullable_T
			};
		}

		/// <summary>
		/// Checks if the type is a nullable value type
		/// </summary>
		internal static bool IsNullableValueType(this ITypeSymbol typeSymbol)
		{
			return typeSymbol is INamedTypeSymbol 
			{
				OriginalDefinition.SpecialType: SpecialType.System_Nullable_T,
				IsValueType: true,
				IsGenericType: true
			};
		}

		/// <summary>
		/// Checks if the type is a nullable value type and gets the underlying type if it is
		/// </summary>
		internal static bool TryGetNullableValueUnderlyingType(this ITypeSymbol typeSymbol, out ITypeSymbol underlyingType)
		{
			underlyingType = null;

			if (typeSymbol is not INamedTypeSymbol 
			    {
				    OriginalDefinition.SpecialType: SpecialType.System_Nullable_T,
				    IsValueType: true,
				    IsGenericType: true
			    } namedType)
			{
				return false;
			}
			
			underlyingType = namedType.TypeArguments[0];
			
			// TODO: decide what to return when the underlying type is not declared due to some compilation error.
			// TypeKind.Error indicates a compilation error, specifically a nullable type where the underlying type was not found.
			// I have observed that IsValueType will be true in such cases even though it is actually unknown whether the missing type is a value type
			// I chose to return false but you may prefer something else. 
			return underlyingType.TypeKind != TypeKind.Error;
		}
		
		/// <summary>
		/// Checks if the type is an enum
		/// </summary>
		internal static bool IsEnum(this ITypeSymbol typeSymbol)
		{
			return typeSymbol is INamedTypeSymbol { EnumUnderlyingType: not null };
		}
		
		/// <summary>
		/// Checks if the type is an enum and gets the underlying enum type if it is
		/// </summary>
		internal static bool TryGetEnum(this ITypeSymbol typeSymbol, out INamedTypeSymbol enumTypeSymbol)
		{
			enumTypeSymbol = null;

			if (typeSymbol is not INamedTypeSymbol { EnumUnderlyingType: not null } namedType)
			{
				return false;
			}
			
			enumTypeSymbol = namedType.EnumUnderlyingType;
				
			return true;
		}
		
		/// <summary>
		/// Checks if the type is a nullable enum
		/// </summary>
		internal static bool IsNullableEnum(this ITypeSymbol typeSymbol)
		{
			var isNullableValueType = typeSymbol.TryGetNullableValueUnderlyingType(out var underlyingType);
			
			return isNullableValueType && underlyingType.IsEnum();
		}
		
		/// <summary>
		/// Checks if the type is a nullable enum and gets the underlying enum typ if it is
		/// </summary>
		internal static bool TryGetNullableEnum(this ITypeSymbol typeSymbol, out INamedTypeSymbol enumTypeSymbol)
		{
			enumTypeSymbol = null;
			
			var isNullableValueType = typeSymbol.TryGetNullableValueUnderlyingType(out var underlyingType);

			if (!isNullableValueType || underlyingType is null)
				return false;
				
			return underlyingType.TryGetEnum(out enumTypeSymbol);
		}

	}
}